<div class="intro">
    <p>
    Extension to help visualize tree structures such as TreeView, Menu or even forms.
    </p>
</div>

<h3>Description</h3>

<p>This module is a Widget to help in the rendering and handling of
tree-like data structures using the Flyweight pattern. It is the
basis for gallery-fwt-treeview module, an implementation of a
TreeView. It could be used to handle other data structures
such as Menus or forms with fields grouped in fieldsets, tabs or
accordion panels.</p>

<p>It contains a manager class (`FlyweightTreeManager`) which is the
factory that provides instances of a node class
(`FlyweightTreeNode`), which inherits from Base and represents each
of the nodes in the tree. The manager is a subclass of Widget and
it is the overall container of the visible representation of the
tree.</p>

<p>The manager stores the tree internally as a plain object with no
methods, events or attributes. The nodes in this tree are called
`iNodes` (for internal nodes). It creates and pools as few node
object instances as it can manage which it then positions over the
iNodes to provide them with the trappings of an active object. In
other words, the manager provides windows to the internal state of
the tree by sliding node instances over the iNodes which hold the
actual status information.</p>

<p>This module is not meant to be instantiated as-is. It
contains what in other languages would be called a abstract
classes, their purpose is to serve as the basis for sets of
classes that inherit from them. Thus, `Y.FWTreeView`
inherits from `Y.FlyweightTreeManager` and `Y.FWTreeNode` inherits
from `Y.FlyweightTreeNode`. </p>

<h3>Performance</h3>

<p>The overall memory consumption is very low. Assuming all nodes
are of the same type, the number of objects the pool might contain
equals the depth of the tree, regardless of the total number of
nodes on the tree. While in a regular tree, the complexity would
grow exponentially with the depth (assuming an average number of
nodes per branch at each level), this module grows linearly with
the depth, regardless of the width.</p>

<p>In tests done with a tree where each and every node is a Widget
instance all supplemented with the widget-parent and widget-child
extensions, a TreeView with about 1000 nodes would be 12 times
faster and take a tenth of the memory with this TreeView than with
the Widget-based one.</p>

<p>It is quite amazing that the speed increase is even higher than
the savings in memory. Initially, I assumed there would be a
tradeoff in between the memory savings and the execution speed and
that might well be the case for trees with a small number of nodes
but as the number of nodes increases, the burden of managing so
much memory takes such an inordinate amount of time that the extra
time the manager takes becomes insignificant and then it is
overtaken quite easily.</p>


<!--
<h3>Performance Data</h3>

<p>I timed a few rendering tests using this TreeView and one based on all Widgets each augmented with WidgetParent and WidgetChild.</p>

<p>The test was simply building a tree with a certain depth and a certain number of children per node.
That is why the resulting number of nodes are not round numbers as they are the consequence of adding all those nodes.
I used FireFox at first, but with the Widget-based tree, it showed the &quot;script is taking too long&quot; message with less than a couple of hundred nodes.
In Chrome I could go to almost 800 before any complaints so I ended up using Chrome for all tests.</p>

<p>With a Widget-based tree, it took 16.5 seconds to draw a tree with 781 nodes.
The same tree took 1.2 seconds using the Flyweight TreeView (all averages of several runs).
So, it is almost 14 times faster.</p>

<p>Then I wondered, how about memory consumption?
With the Widget-based TreeView approach and 781 nodes, Chrome simply died when trying to take the heap snapshot while 10.4MB with this TreeView.
So I made the tree one level shallower and with 156 nodes, the Widget-based TreeView took 49MB against 6MB with this version;
less than one eighth the memory consumption.</p>

<p>The obvious difference is that with 156 nodes in a tree 3 levels deep,
the Widget-based approach requires 156 Widgets,
one for each tree-node plus one for the TreeView container.
When using the Flyweight pattern you get  just one Widget (the overall container for the TreeView)
and only 3 tree-node instances, one for each level of depth.
Of course, in both cases, the markup created is the same and in the flyweight TreeView,
there is the tree configuration object, which is a passive object for data storage, no methods, no nothing in it.</p>
-->

<h3>Usage</h3>

<p>Both classes in this module are meant to be subclassed, for example, in `gallery-fwt-treeview` you have:</p>

```
YUI.add('gallery-fwt-treeview', function (Y, NAME) {
    Y.FWTreeView = Y.Base.create(
        NAME,
        Y.FlyweightTreeManager,
        [ ],
        {
             // ......
        }
    );
    Y.FWTreeNode = Y.Base.create(
        NAME,
        Y.FlyweightTreeNode,
        [ ],
        {
             // ......
        }
    );

}, '@VERSION@' , {
    requires: ['gallery-flyweight-tree', 'base-build']
});

```

<p>It can handle multiple node types (subclasses of
FlyweightTreeNode) delivering the correct type for each node.</p>
